Для каждого упражнения написать программную реализацию.

Код пишите в файлах с расширением .py в кодировке UTF-8 (в PyCharm работает по умолчанию). Каждую задачу необходимо сохранять в отдельный файл. Рекомендуем использовать английские имена, например, les_4_task_1, les_4_task_2, и т.д.

Для оценки «Отлично» необходимо выполнить оба задания.

Результаты анализа сохранить в виде комментариев в файле с кодом.

1. Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.

Примечание. Идеальным решением будет:

a. выбрать хорошую задачу, которую имеет смысл оценивать,

b. написать 3 варианта кода (один у вас уже есть),

c. проанализировать 3 варианта и выбрать оптимальный,

d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),

e. написать общий вывод: какой из трёх вариантов лучше и почему.

2. Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.


Первый — с помощью алгоритма «Решето Эратосфена».

Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.

Второй — без использования «Решета Эратосфена».

В первом случае алгоритм работает  
на 100 числах рабоатет 22 милисекунды и вызывает 6 функций

# python -m timeit -n 1000 -s "import les_4_task_2" "les_4_task_2.sieve(100)"
# 1000 loops, best of 3: 22 usec per loop

# 6 function calls in 0.000 seconds cProfile.run('sieve(1000)')


Во втором случае

аглоритм работает на 100 числах 189 милисекунды и вызывает 172 функции. 
#  python -m timeit -n 1000 -s "import les_4_task_2" "les_4_task_2.prime(100)"
# 1000 loops, best of 3: 289 usec per loop
# 172 function calls in 0.017 seconds Profile.run('prime(1000)')


Примечание. Вспомните классический способ проверки числа на простоту.

Пример работы программ:

    >>> sieve(2)
    3
    >>> prime(4)
    7
    >>> sieve(5)
    11
    >>> prime(1)
    2
Примечание по профилированию кода: для получения достоверных результатов при замере времени необходимо исключить/заменить функции print() и input() в анализируемом коде. С ними вы будете замерять время вывода данных в терминал и время, потраченное пользователем, на ввод данных, 
а не быстродействие самого алгоритма.
