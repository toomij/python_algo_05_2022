# TODO: 2. Написать два алгоритма нахождения i-го по счёту простого числа.
#  Функция нахождения простого числа должна принимать
#  на вход натуральное и возвращать соответствующее простое число.
#  Проанализировать скорость и сложность алгоритмов.
#
# Первый — с помощью алгоритма «Решето Эратосфена».
#
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
# Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
#
# Второй — без использования «Решета Эратосфена».
#
# Примечание. Вспомните классический способ проверки числа на простоту.
#
# Пример работы программ:
#
#     >>> sieve(2)
#     3
#     >>> prime(4)
#     7
#     >>> sieve(5)
#     11
#     >>> prime(1)
#     2
# Примечание по профилированию кода: для получения достоверных результатов при замере времени необходимо
# исключить/заменить функции print() и input() в анализируемом коде.
# С ними вы будете замерять время вывода данных в терминал и время, потраченное пользователем, на ввод данных,
# а не быстродействие самого алгоритма.

# Решето Эратосфена


def sieve(n):

    #n = int(input('До какого числа получать простые числа: '))

    sieve = [i for i in range(n)]
    sieve[1] = 0


    for i in range(2, n):
        if sieve[i] != 0:
            j = i * 2
            while j < n:
                sieve[j] = 0
                j += i


    result = [i for i in sieve if i != 0]
    #print(result)
    return result

def prime(n):
    #a, n = True, int(input())  # n - число, до которого хотим дойти
    a = True
    result = []
    for x in range(2, n):
        for y in range(1, n):
            if x != y and y != 1:
                if not x % y:
                    a = False
                    break
        if a == True:
            #print(x, end=' ')
            result.append(x)
        a = True
    #print(result)
    return result

sieve(6)
prime(6)
